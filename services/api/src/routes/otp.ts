import { Router } from 'express';
import { z } from 'zod';
import { OtpVerification } from '../models/OtpVerification';
import { User } from '../models/User';
import { emailService } from '../utils/emailService';
import { smsService } from '../utils/smsService';
import { whatsappService } from '../utils/whatsappService';
import { authenticateJwt } from '../middleware/auth';

const router = Router();

// Async error wrapper
const asyncHandler = (fn: Function) => (req: any, res: any, next: any) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

// Schema for sending OTP
const sendOTPSchema = z.object({
  email: z.string().email().optional(),
  phone: z.string().optional(),
  type: z.enum(['signup', 'login', 'password_reset', 'phone_verification', 'email_verification']),
  purpose: z.enum(['registration', 'authentication', 'password_reset', 'profile_update'])
});

// Schema for verifying OTP
const verifyOTPSchema = z.object({
  email: z.string().email().optional(),
  phone: z.string().optional(),
  otp: z.string().length(6),
  type: z.enum(['signup', 'login', 'password_reset', 'phone_verification', 'email_verification'])
});

// Send OTP endpoint
router.post('/send', asyncHandler(async (req: any, res: any) => {
  try {
    const parsed = sendOTPSchema.safeParse(req.body);
    
    if (!parsed.success) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: parsed.error.flatten().fieldErrors
      });
    }
    
    const { email, phone, type, purpose } = parsed.data;
    
    // Must have either email or phone
    if (!email && !phone) {
      return res.status(400).json({
        success: false,
        error: 'Either email or phone is required'
      });
    }
    
    // Check if user exists (for certain purposes)
    if (purpose === 'authentication' || purpose === 'password_reset') {
      const existingUser = await User.findOne({
        $or: [
          ...(email ? [{ email }] : []),
          ...(phone ? [{ phone }] : [])
        ]
      });
      
      if (!existingUser) {
        return res.status(404).json({
          success: false,
          error: 'User not found with this email/phone'
        });
      }
    }
    
    // Check for recent OTP requests (rate limiting)
    const recentOTP = await OtpVerification.findOne({
      $or: [
        ...(email ? [{ email }] : []),
        ...(phone ? [{ phone }] : [])
      ],
      type,
      createdAt: { $gte: new Date(Date.now() - 60 * 1000) } // Last 1 minute
    });
    
    if (recentOTP) {
      return res.status(429).json({
        success: false,
        error: 'Please wait 1 minute before requesting another OTP'
      });
    }
    
    // Generate and save OTP
    const otpDoc = await OtpVerification.create({
      email,
      phone,
      type,
      purpose,
      otp: '' // Will be generated by pre-save hook
    });
    
    // Send OTP via appropriate channel
    let sent = false;
    const purposeText = purpose.replace('_', ' ');
    
    if (email && (type === 'signup' || type === 'email_verification' || type === 'password_reset')) {
      sent = await emailService.sendOTPEmail(email, otpDoc.otp, purposeText);
    }
    
    if (phone && (type === 'phone_verification' || type === 'login')) {
      if (!smsService.isValidPhoneNumber(phone)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid phone number format'
        });
      }
      
      // Try SMS first, then fallback to WhatsApp
      sent = await smsService.sendOTPSMS(phone, otpDoc.otp, purposeText);
      
      if (!sent) {
        console.log('SMS failed, trying WhatsApp...');
        sent = await whatsappService.sendOTPWhatsApp(phone, otpDoc.otp, purposeText);
      }
    }
    
    if (!sent) {
      await OtpVerification.findByIdAndDelete(otpDoc._id);
      return res.status(500).json({
        success: false,
        error: 'Failed to send OTP. Please try again.'
      });
    }
    
    res.json({
      success: true,
      message: `OTP sent successfully to ${email ? 'email' : 'phone'}`,
      expiresAt: otpDoc.expiresAt,
      method: email ? 'email' : 'sms'
    });
    
  } catch (error: any) {
    console.error('Error sending OTP:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send OTP'
    });
  }
}));

// Verify OTP endpoint
router.post('/verify', asyncHandler(async (req: any, res: any) => {
  try {
    const parsed = verifyOTPSchema.safeParse(req.body);
    
    if (!parsed.success) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: parsed.error.flatten().fieldErrors
      });
    }
    
    const { email, phone, otp, type } = parsed.data;
    
    // Find OTP record
    const otpDoc = await OtpVerification.findOne({
      $or: [
        ...(email ? [{ email }] : []),
        ...(phone ? [{ phone }] : [])
      ],
      type,
      verified: false,
      expiresAt: { $gt: new Date() }
    }).sort({ createdAt: -1 });
    
    if (!otpDoc) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired OTP'
      });
    }
    
    // Check attempt limit
    if (otpDoc.attempts >= otpDoc.maxAttempts) {
      await OtpVerification.findByIdAndDelete(otpDoc._id);
      return res.status(400).json({
        success: false,
        error: 'Too many attempts. Please request a new OTP.'
      });
    }
    
    // Verify OTP
    if (otpDoc.otp !== otp) {
      otpDoc.attempts += 1;
      await otpDoc.save();
      
      return res.status(400).json({
        success: false,
        error: 'Invalid OTP',
        attemptsLeft: otpDoc.maxAttempts - otpDoc.attempts
      });
    }
    
    // Mark as verified
    otpDoc.verified = true;
    otpDoc.verifiedAt = new Date();
    await otpDoc.save();
    
    // Update user verification status if applicable
    if (type === 'email_verification' && email) {
      await User.findOneAndUpdate(
        { email },
        { emailVerified: true }
      );
    }
    
    if (type === 'phone_verification' && phone) {
      await User.findOneAndUpdate(
        { phone },
        { phoneVerified: true }
      );
    }
    
    res.json({
      success: true,
      message: 'OTP verified successfully',
      verified: true,
      verificationId: otpDoc._id // Can be used for subsequent operations
    });
    
  } catch (error: any) {
    console.error('Error verifying OTP:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to verify OTP'
    });
  }
}));

// Resend OTP endpoint
router.post('/resend', asyncHandler(async (req: any, res: any) => {
  try {
    const { email, phone, type } = req.body;
    
    // Find the last OTP request
    const lastOtp = await OtpVerification.findOne({
      $or: [
        ...(email ? [{ email }] : []),
        ...(phone ? [{ phone }] : [])
      ],
      type,
      verified: false
    }).sort({ createdAt: -1 });
    
    if (!lastOtp) {
      return res.status(400).json({
        success: false,
        error: 'No pending OTP found'
      });
    }
    
    // Check if it's too soon to resend (30 seconds)
    const timeSinceLastOTP = Date.now() - lastOtp.createdAt.getTime();
    if (timeSinceLastOTP < 30 * 1000) {
      return res.status(429).json({
        success: false,
        error: 'Please wait 30 seconds before resending',
        waitTime: Math.ceil((30 * 1000 - timeSinceLastOTP) / 1000)
      });
    }
    
    // Generate new OTP
    const newOtp = Math.floor(100000 + Math.random() * 900000).toString();
    lastOtp.otp = newOtp;
    lastOtp.attempts = 0; // Reset attempts
    lastOtp.expiresAt = new Date(Date.now() + 10 * 60 * 1000); // New 10-minute expiry
    await lastOtp.save();
    
    // Send new OTP
    let sent = false;
    const purposeText = lastOtp.purpose.replace('_', ' ');
    
    if (email && (type === 'signup' || type === 'email_verification' || type === 'password_reset')) {
      sent = await emailService.sendOTPEmail(email, newOtp, purposeText);
    }
    
    if (phone && (type === 'phone_verification' || type === 'login')) {
      sent = await smsService.sendOTPSMS(phone, newOtp, purposeText);
      
      if (!sent) {
        console.log('SMS resend failed, trying WhatsApp...');
        sent = await whatsappService.sendOTPWhatsApp(phone, newOtp, purposeText);
      }
    }
    
    if (!sent) {
      return res.status(500).json({
        success: false,
        error: 'Failed to resend OTP'
      });
    }
    
    res.json({
      success: true,
      message: 'OTP resent successfully',
      expiresAt: lastOtp.expiresAt
    });
    
  } catch (error: any) {
    console.error('Error resending OTP:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to resend OTP'
    });
  }
}));

// Get OTP status (for authenticated users)
router.get('/status', authenticateJwt, asyncHandler(async (req: any, res: any) => {
  try {
    const userId = req.auth.userId;
    const user = await User.findById(userId).select('email phone emailVerified phoneVerified');
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    res.json({
      success: true,
      verification: {
        email: {
          address: user.email,
          verified: user.emailVerified
        },
        phone: {
          number: user.phone,
          verified: user.phoneVerified
        }
      }
    });
    
  } catch (error: any) {
    console.error('Error getting OTP status:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get verification status'
    });
  }
}));

export default router;
